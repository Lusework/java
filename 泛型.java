泛型简介：
{
    1：为什么需要泛型
    （1）集合中对数据类型没有任何限制，这样可能会引发些问题。
    
    （2）由于把对象“丢"进集合时，集合丢失了对象的状态信息，集合
        只知道盛装的是Object，因此取出集合元素是还需要进行强制转换。
        这种强制转换即增加了编程的复杂度，同时可能引发ClassCastException（类型转换异常）
    2：什么是泛型：
        java的参数化类型被称为泛型（Generic）
        
        
    3：使用泛型：
        创建这种特殊集合的方法是：在集合接口、类后增加尖括号，尖括号放一个数据类型，
        就表明这个集合接口、集合类只能保存特定类型的对象。
        
    4：java7的菱形语法：
          从java7开始，java允许在构造器后不需要带完整的泛型信息，只要给出一对尖括号（<>）
           就行，Java可以推断尖括号里什么数据类型。 
           例：
           //指定strList内只能存放String类型的参数。
           List<String> setList = new ArrayList<>();
           //指定scores内只能存放String类型与Integer的类型。
           Map<String,Integer> scores = new HashMap<>();
           
   
}

深入泛型：
{
        1：  定义泛型接口、类
            所谓泛型，就是允许在定义接口、类、方法时使用类型参数，这些类型参数将在申明变量，
            创建对象、调用方法时指定。java泛型设计的原则是，只要代码在编译时没有出现警告，
            就不会遇到运行时ClassCastException异常
            
            
        2：泛型的实质：
            允许在定义接口、类时申明类型参数，类型参数在整个接口、类体内可当成类型使用，几乎可
            使用普通类型的地方都可以使用这种类型参数。
            可以为任何类、接口增加类型申明。
            
        3：从泛型类派生子类：
                当创建了带泛型声明的接口、父类之后，可以为该接口创建实现类，或从该父类派生子类
                ，需要说明的是，当使用这些接口、父类时不能再包含类型参数。
                
                
         5：并不存在的泛型类：
                如下代码的返回结果：
                //分别创建List<String>对象和List<Integer>对象
                List<String> l = new ArrayList<>;
                List<Integer> l1 = new ArrayList<>;
                
                //调用getClass（）方法来比较l1与l的类是否相等
                System.out.println(l1.getClass() == l.getClass());
                
                代码输出结果为true，因为不管泛型的实际类型参数是什么，他们在运行时总有相同的类。
                
                不管为泛型的类型形参传入哪一种类型实参，对于java来说，他们依然被当成同一个类处理
                在内存中也只占用一块内存空间，因此在静态方法、静态初始化块或则静态变量的申明和初始化中
                不允许使用类型参数。
                
                
          6：类型通配符:
            当使用一个泛型类时（包括申明变量和创建对象两种情况），都应该为这个泛型类传入一个类型实参。
            
            为了表示各种泛型List的父类，可以使用类型通配符，类型通配符是一个问号（？），将一个（？）
            作为类型实参传给List集合，写作：List<?>(意思是元素类型未知的List),问号（？）就叫通配符，
            他的元素类型可以匹配任何类型。
            
            
            
            
            
           7：设置类型通配符的上限：
                List<? extends shape>
                此处的问号表示一个未知的类型，但是此处的未知类型一定是shape的子类（也可以是shape本身），
                因此可以称shape是这个通配符的上限。
                
                
            8：泛型方法：
                （1）所谓泛型方法，就是在声明方法时定义一个或多个类型形参。
                （2）泛型方法比普通方法的方法签名多了类型形参声明，类型形参声明使用尖括号括起来，
                      多个类型形参之间使用逗号隔开，所有的类型形参声明放在方法修饰符和方法返回值之间。
                      
                      
            9：通配符和泛型方法的区别：
               （1）   通配符就是被用来支持灵活的子类化的。
               （2）泛型方法允许类型形参被用来表示方法的一个或多个参数之间的类型依赖关系，或者方法返回值
                    与参数之间的类型依赖关系，如果没有这样的依赖关系，就不应该使用泛型方法。
                    
                 类型通配符与泛型方法最显著的区别是：类型通配符既可以在方法签名中定义形参的类型，也可以用于定
                 义变量的类型；但是泛型方法中得类型形参必须在对应方法中声明。


                 
                  

                      
            
            
            
                
                
                
                
                
        
}